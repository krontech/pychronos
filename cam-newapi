#!/usr/bin/python3

import inspect
import logging
import dbus
import dbus.service
import dbus.mainloop.glib
from gi.repository import GLib

import pychronos
from pychronos import camera
from pychronos.sensors import lux1310, frameGeometry
import pychronos.regmaps as regmaps

interface = 'com.krontech.chronos.control'

#-----------------------------------------------------------------
# Some constants that ought to go into a board-specific dict.
FPGA_BITSTREAM = "/var/camera/FPGA.bit"
GPIO_ENCA = "/sys/class/gpio/gpio20/value"
GPIO_ENCB = "/sys/class/gpio/gpio26/value"
GPIO_ENCSW = "/sys/class/gpio/gpio27/value"
REC_LED_FRONT = "/sys/class/gpio/gpio41/value"
REC_LED_BACK = "/sys/class/gpio/gpio25/value"
#-----------------------------------------------------------------

class controlApi(dbus.service.Object):
    ## This feels like a duplication of the Python exceptions.
    ERROR_NOT_IMPLEMENTED_YET = 9999
    VALUE_ERROR               = 1

    def __init__(self, bus, path, mainloop, camera):
        # FIXME: This seems hacky, just calling the class method directly.
        # Shouldn't we be using a super() call somehow?
        dbus.service.Object.__init__(self, bus, path)
        self.bus = bus
        self.mainloop = mainloop
    
        self.camera = camera
        self.io = regmaps.ioInterface()
        self.display = regmaps.display()

        # Install a callback to catch parameter and state changes.
        self.camera.setOnChange(self.onChangeHandler)
        self.changeset = None

        self.callLater(0.5, self.doReset, {'reset':True, 'sensor':True})
    
    ## Internal helper to iterate over a generator from the GLib mainloop.
    ## TODO: Do we need a callback for exception handling?
    def stepGenerator(self, generator, onError=None):
        try:
            delay = next(generator)
            GLib.timeout_add(int(delay * 1000), self.stepGenerator, generator)
        except StopIteration:
            pass
        except Exception as error:
            if (onError):
                onError(error)
        # Always return false to remove the Glib source for the last step.
        return False
    
    ## Internal helper to run a generator. This ought to be the preferred way to
    ## invoke a generator from within GLib's mainloop.
    def runGenerator(self, generator, onError=None):
        GLib.idle_add(self.stepGenerator, generator, onError)

    ## Internal helper to call something in the future. Should function identically
    ## to Twisted's reactor.callLater function, except that the yield asleep thing
    ## is just replaced with a yield of the desired sleep time.
    def callLater(self, timeout, callback, *args, **kwargs):
        msec = int(timeout * 1000)
        if (inspect.isgeneratorfunction(callback)):
            ## The callback will yeild. Use stepGenerator instead to handle it.
            GLib.timeout_add(msec, self.stepGenerator, callback(*args, **kwargs))
        else:
            # Just a plain old function, call directly but force it to return False
            GLib.timeout_add(msec, lambda *args, **kwargs: callback(*args, **kwargs) and False, *args, **kwargs)
    
    ## Internal helper to convert types into D-Bus compatible versions. For
    ## now this only applies to dictionaries, where the key/value pairs are
    ## converted into an 'a{sv}' signature.
    def dbusifyTypes(self, src, variant_level=0):
        # For everything other than dicts - do nothing.
        if not isinstance(src, dict):
            return src
        
        # For dicts, convert all values into variants.
        result = dbus.types.Dictionary(variant_level=variant_level)
        for key in src:
            value = src[key]
            if isinstance(value, int):
                result[key] = dbus.types.Int32(value, variant_level=1)
            elif isinstance(value, float):
                result[key] = dbus.types.Double(value, variant_level=1)
            elif isinstance(value, dict):
                result[key] = dbusifyTypes(value, variant_level=1)
            else:
                result[key] = dbus.types.String(value, variant_level=1)
        return result
    
    #===============================================================================================
    #Method('notify', arguments='', returns='a{sv}'),
    def onChangeHandler(self, pName, pValue):
        logging.debug("Parameter %s -> %s", pName, pValue)
        if not self.changeset:
            self.changeset = {pName: pValue}
            GLib.timeout_add(100, self.notifyChanges)
        else:
            self.changeset[pName] = pValue

    def notifyChanges(self):
        self.notify(self.changeset)
        self.changeset = None
        return False
    
    @dbus.service.signal(interface, signature='a{sv}')
    def notify(self, args):
        return self.dbusifyTypes(self.changeset)
    
    #===============================================================================================
    #Method('get', arguments='as', returns='a{sv}')
    #Method('set', arguments='a{sv}', returns='a{sv}')
    @dbus.service.method(interface, in_signature='as', out_signature='a{sv}')
    def get(self, args):
        data = {}
        for name in args:
            if hasattr(self.camera, name):
                data[name] = self.dbusifyTypes(getattr(self.camera, name))
        return data
    
    @dbus.service.method(interface, in_signature='a{sv}', out_signature='a{sv}')
    def set(self, args):
        for name in args:
            if hasattr(self.camera, name):
                setattr(self.camera, name, args[name])
        return self.status()
    
    #===============================================================================================
    #Method('status', arguments='', returns='a{sv}')
    @dbus.service.method(interface, in_signature='', out_signature='a{sv}')
    def status(self):
        return {'state':self.currentState}

    #===============================================================================================
    #Method('doReset', arguments='a{sv}', returns='a{sv}'),
    @dbus.service.method(interface, in_signature='a{sv}', out_signature='a{sv}')
    def doReset(self, args):
        self.callLater(0.0, self.runReset, args)
        self.currentState = 'reinitializing'
        return self.status()

    def runReset(self, args):
        recal = False
        reinitAll = args.get('all', False)
        if args.get('fpga') or reinitAll:
            reinitAll = True
            recal = True
            self.camera.reset(FPGA_BITSTREAM)

        if args.get('reset'):
            recal = True
            self.camera.reset()
            
        if args.get('sensor') or reinitAll:
            recal = True
            self.camera.sensor.reset()

        if recal:
            self.display.whiteBalance[0] = int(1.5226 * 4096)
            self.display.whiteBalance[1] = int(1.0723 * 4096)
            self.display.whiteBalance[2] = int(1.5655 * 4096)
            
            #self.currentState = 'calibrating'
            #self.runGenerator(self.startCalibration({'analog':True, 'zeroTimeBlackCal':True}))
            self.currentState = 'idle'
        else:
            self.currentState = 'idle'

    #===============================================================================================
    #Method('startAutoWhiteBalance', arguments='a{sv}', returns='a{sv}'),
    #Method('revertAutoWhiteBalance', arguments='a{sv}', regutns='a{sv}'),
    #Method('startBlackCalibration', arguments='a{sv}', regutns='a{sv}'),
    #Method('startZeroTimeBlackCal', arguments='a{sv}', regutns='a{sv}'),
    @dbus.service.method(interface, in_signature='a{sv}', out_signature='a{sv}')
    def startAutoWhiteBalance(self, args):
        logging.info('starting white balance')
        try:
            self.runGenerator(self.camera.startWhiteBalance(args))
            return {
                "state": self.camera.state
            }
        except CameraError as e:
            return {
                "state": self.camera.state,
                "error": e.message
            }

    @dbus.service.method(interface, in_signature='a{sv}', out_signature='a{sv}')
    def revertAutoWhiteBalance(self, args):
        self.camera.wbMatrix = self.camera.wbCustom
        return {
            "state": self.camera.state
        }
    
    @dbus.service.method(interface, in_signature='a{sv}', out_signature='a{sv}')
    def startBlackCalibration(self, args):
        logging.info('starting standard black calibration')
        try:
            self.runGenerator(self.camera.startBlackCal())
            return {
                "state": self.camera.state
            }
        except Exception as e:
            return {
                "state": self.camera.state,
                "error": e.message
            }
    
    @dbus.service.method(interface, in_signature='a{sv}', out_signature='a{sv}')
    def startZeroTimeBlackCal(self, args):
        logging.info('starting zero-time black calibration')
        try:
            self.runGenerator(self.camera.startZeroTimeBlackCal())
            return {
                "state": self.camera.state
            }
        except CameraError as e:
            return {
                "state": self.camera.state,
                "error": e.message
            }

    @dbus.service.method(interface, in_signature='a{sv}', out_signature='a{sv}')
    def startAnalogCalibration(self, args):
        logging.info('starting analog calibration')
        try:
            self.runGenerator(self.camera.sensor.startAnalogCal())
            return {
                "state": self.camera.state
            }
        except CameraError as e:
            return {
                "state": self.camera.state,
                "error": e.message
            }
    
    @dbus.service.method(interface, in_signature='a{sv}', out_signature='a{sv}')
    def startRecording(self, args):
        logging.info('starting analog calibration')
        try:
            self.runGenerator(self.camera.startRecording())
            return {
                "state": self.camera.state
            }
        except CameraError as e:
            return {
                "state": self.camera.state,
                "error": e.message
            }



    #===============================================================================================
    #Method('testResolution', arguments='a{sv}', returns='a{sv}'),
    @dbus.service.method(interface, in_signature='a{sv}', out_signature='a{sv}')
    def testResolution(self, args):
        if (self.camera.sensor.isValidResolution(args)):
            fpMin, fpMax = self.camera.sensor.getPeriodRange(args)
            expMin, expMax = self.camera.sensor.getExposureRange(args, fpMin)
            return {
                "cameraMaxFrames": self.camera.getRecordingMaxFrames(args),
                "minFramePeriod": int(fpMin * 1000000000),
                "exposureMin": int(expMin * 1000000000),
                "exposureMax": int(expMax * 1000000000)
            }
        else:
            return {
                "error": "Invalid Resolution"
            }

# Run the control API
if __name__ == "__main__":
    # Enable logging.
    logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(levelname)s [%(funcName)s] %(message)s')

    ## TODO: Initialize the FPGA.
    ## TODO: This needs to go into an init script somewhere.

    # Use the GLib mainloop.
    dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
    mainloop = GLib.MainLoop()

    # Setup resources.
    cam  = camera(lux1310())
    bus  = dbus.SystemBus()
    name = dbus.service.BusName('com.krontech.chronos.control', bus=bus)
    obj  = controlApi(bus, '/com/krontech/chronos/control', mainloop, cam)

    # Run the mainloop.
    logging.info("Running control service...")
    mainloop.run()
